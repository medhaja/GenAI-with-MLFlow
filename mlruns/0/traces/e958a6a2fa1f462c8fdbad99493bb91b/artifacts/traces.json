{"spans": [{"name": "RetrievalQA", "context": {"span_id": "0x81287544a0ad5d2b", "trace_id": "0x583868fcae1424770dc57883840d8cd8"}, "parent_id": null, "start_time": 1723666175094980700, "end_time": 1723666176444250700, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"e958a6a2fa1f462c8fdbad99493bb91b\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"query\": \"what is Hierarchical Page table?\"}", "mlflow.spanOutputs": "{\"result\": \" Hierarchical Page table is a memory management scheme that is used when the number of pages is very high. It divides the page table into multiple levels to reduce its size and make it more efficient. This is commonly used in two-level paging architectures.\", \"source_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 59}, \"page_content\": \"Page  61                       \\n \\n \\nAddress  translation  scheme  for a two-level  paging  architecture:  \\n \\n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \\nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \\nchain of elements hashing to the same location. Virtual page numbers are compared in this  \\nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \\nextracted.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 60}, \"page_content\": \"Page  62      \\n   \\n \\n3. Inverted  Page  Table : \\n\\uf0de One  entry  for each  real  page  of memory.  \\n\\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \\ninformation  about  the process  that  owns  that  page.  \\n\\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \\nthe table  when  a page  reference  occurs.  \\n \\nShared  Pages  \\nShared  code  \\n\\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \\ncompilers,  window  systems).  \\n\\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \\nPrivate  code  and  data  \\n\\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \\n\\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \\n \\nSEGMENTATION   \\n \\nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \\nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\", \"type\": \"Document\"}]}"}, "events": []}, {"name": "VectorStoreRetriever", "context": {"span_id": "0x6913fd1377e63632", "trace_id": "0x583868fcae1424770dc57883840d8cd8"}, "parent_id": "0x81287544a0ad5d2b", "start_time": 1723666175115522200, "end_time": 1723666175448155200, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"e958a6a2fa1f462c8fdbad99493bb91b\"", "mlflow.spanType": "\"RETRIEVER\"", "metadata": "{\"ls_retriever_name\": \"vectorstore\", \"ls_vector_store_provider\": \"FAISS\", \"ls_embedding_provider\": \"OpenAIEmbeddings\"}", "mlflow.spanInputs": "\"what is Hierarchical Page table?\"", "mlflow.spanOutputs": "[{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 59}, \"page_content\": \"Page  61                       \\n \\n \\nAddress  translation  scheme  for a two-level  paging  architecture:  \\n \\n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \\nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \\nchain of elements hashing to the same location. Virtual page numbers are compared in this  \\nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \\nextracted.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 60}, \"page_content\": \"Page  62      \\n   \\n \\n3. Inverted  Page  Table : \\n\\uf0de One  entry  for each  real  page  of memory.  \\n\\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \\ninformation  about  the process  that  owns  that  page.  \\n\\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \\nthe table  when  a page  reference  occurs.  \\n \\nShared  Pages  \\nShared  code  \\n\\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \\ncompilers,  window  systems).  \\n\\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \\nPrivate  code  and  data  \\n\\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \\n\\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \\n \\nSEGMENTATION   \\n \\nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \\nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\", \"type\": \"Document\"}]"}, "events": []}, {"name": "StuffDocumentsChain", "context": {"span_id": "0x77287d2f9aa1d60c", "trace_id": "0x583868fcae1424770dc57883840d8cd8"}, "parent_id": "0x81287544a0ad5d2b", "start_time": 1723666175449159900, "end_time": 1723666176443250900, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"e958a6a2fa1f462c8fdbad99493bb91b\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"input_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 59}, \"page_content\": \"Page  61                       \\n \\n \\nAddress  translation  scheme  for a two-level  paging  architecture:  \\n \\n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \\nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \\nchain of elements hashing to the same location. Virtual page numbers are compared in this  \\nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \\nextracted.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 60}, \"page_content\": \"Page  62      \\n   \\n \\n3. Inverted  Page  Table : \\n\\uf0de One  entry  for each  real  page  of memory.  \\n\\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \\ninformation  about  the process  that  owns  that  page.  \\n\\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \\nthe table  when  a page  reference  occurs.  \\n \\nShared  Pages  \\nShared  code  \\n\\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \\ncompilers,  window  systems).  \\n\\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \\nPrivate  code  and  data  \\n\\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \\n\\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \\n \\nSEGMENTATION   \\n \\nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \\nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\", \"type\": \"Document\"}], \"question\": \"what is Hierarchical Page table?\"}", "mlflow.spanOutputs": "{\"output_text\": \" Hierarchical Page table is a memory management scheme that is used when the number of pages is very high. It divides the page table into multiple levels to reduce its size and make it more efficient. This is commonly used in two-level paging architectures.\"}"}, "events": []}, {"name": "LLMChain", "context": {"span_id": "0x8448c09f125fdb5b", "trace_id": "0x583868fcae1424770dc57883840d8cd8"}, "parent_id": "0x77287d2f9aa1d60c", "start_time": 1723666175451175800, "end_time": 1723666176443250900, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"e958a6a2fa1f462c8fdbad99493bb91b\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"question\": \"what is Hierarchical Page table?\", \"context\": \"Page  61                       \\n \\n \\nAddress  translation  scheme  for a two-level  paging  architecture:  \\n \\n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \\nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \\nchain of elements hashing to the same location. Virtual page numbers are compared in this  \\nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \\nextracted.\\n\\nPage  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\\n\\nPage  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\\n\\nPage  62      \\n   \\n \\n3. Inverted  Page  Table : \\n\\uf0de One  entry  for each  real  page  of memory.  \\n\\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \\ninformation  about  the process  that  owns  that  page.  \\n\\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \\nthe table  when  a page  reference  occurs.  \\n \\nShared  Pages  \\nShared  code  \\n\\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \\ncompilers,  window  systems).  \\n\\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \\nPrivate  code  and  data  \\n\\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \\n\\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \\n \\nSEGMENTATION   \\n \\nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \\nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\"}", "mlflow.spanOutputs": "{\"text\": \" Hierarchical Page table is a memory management scheme that is used when the number of pages is very high. It divides the page table into multiple levels to reduce its size and make it more efficient. This is commonly used in two-level paging architectures.\"}"}, "events": [{"name": "text", "timestamp": 1723666175451175, "attributes": {"text": "Prompt after formatting:\n\u001b[32;1m\u001b[1;3mUse the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n\nPage  61                       \n \n \nAddress  translation  scheme  for a two-level  paging  architecture:  \n \n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \nchain of elements hashing to the same location. Virtual page numbers are compared in this  \nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \nextracted.\n\nPage  60                       \n\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \nis set to \"valid,\" this value indicates that the associated page is in the process' logical - \naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \"invalid,\"  this  value  indicates  \nthat  the page  is not in the process'  logical -address  space.  \n\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \nbit for each  page  to allow  or disallow  accesses  to that  page.  \n \n(Valid  (v) or invalid  (i) bit in a page  table)  \n \nStructure  of the Page Table   \n \nThere  are different  structures  of page  table  described  as follows:  \n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \na logical  address  is as follows:  \n \nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \nthe outer  page  table.  \nTwo -Level  Page -Table  Scheme:\n\nPage  58                       \n \n \nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \n \nExample:  \nConsider  a page  size  of 4 bytes  and  a \nphysical memory of  32 bytes (8 pages), we  \nshow how the user's view of memory can  \nbe mapped into physical memory. Logical  \naddress 0 is page 0, offset 0. Indexing into  \nthe page table, we find that page 0 is in  \nframe 5. Thus, logical address 0 maps to  \nphysical  address  20 (= (5 x 4) + 0). Logical  \naddress   3   (page   0,   offset   3)   maps   to \nphysical  address  23 (= (5 x 4) + 3). Logical  \naddress 4 is page 1, offset 0; according to  \nthe page  table,  page  1 is mapped  to frame  \n6. Thus, logical address 4 maps to physical  \naddress  24 (= (6 x 4) + 0). Logical  address  \n13 maps  to physical  address  9(= (2 x 4)+1).  \n \n \n \n \n \n \nHardware  Support  for Paging:                                                                                                       \nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \nhardware  page  table  values  from  the stored  user  page  table.  \nImplementation  of Page  Table  \n\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \n\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \npage  table  and  one for the data/instruction.  \n\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \nPaging  Hardware  With  TLB  \nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\n\nPage  62      \n   \n \n3. Inverted  Page  Table : \n\uf0de One  entry  for each  real  page  of memory.  \n\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \ninformation  about  the process  that  owns  that  page.  \n\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \nthe table  when  a page  reference  occurs.  \n \nShared  Pages  \nShared  code  \n\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \ncompilers,  window  systems).  \n\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \nPrivate  code  and  data  \n\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \n\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \n \nSEGMENTATION   \n \nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\n\nQuestion: what is Hierarchical Page table?\nHelpful Answer:\u001b[0m"}}]}, {"name": "OpenAI", "context": {"span_id": "0x8dafa6ee523f23ca", "trace_id": "0x583868fcae1424770dc57883840d8cd8"}, "parent_id": "0x8448c09f125fdb5b", "start_time": 1723666175451963600, "end_time": 1723666176443250900, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"e958a6a2fa1f462c8fdbad99493bb91b\"", "mlflow.spanType": "\"LLM\"", "invocation_params": "{\"model_name\": \"gpt-3.5-turbo-instruct\", \"temperature\": 0.0, \"top_p\": 1.0, \"frequency_penalty\": 0.0, \"presence_penalty\": 0.0, \"n\": 1, \"logit_bias\": {}, \"max_tokens\": 256, \"_type\": \"openai\", \"stop\": null}", "options": "{\"stop\": null}", "batch_size": "1", "mlflow.spanInputs": "[\"Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\\n\\nPage  61                       \\n \\n \\nAddress  translation  scheme  for a two-level  paging  architecture:  \\n \\n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \\nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \\nchain of elements hashing to the same location. Virtual page numbers are compared in this  \\nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \\nextracted.\\n\\nPage  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\\n\\nPage  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\\n\\nPage  62      \\n   \\n \\n3. Inverted  Page  Table : \\n\\uf0de One  entry  for each  real  page  of memory.  \\n\\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \\ninformation  about  the process  that  owns  that  page.  \\n\\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \\nthe table  when  a page  reference  occurs.  \\n \\nShared  Pages  \\nShared  code  \\n\\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \\ncompilers,  window  systems).  \\n\\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \\nPrivate  code  and  data  \\n\\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \\n\\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \\n \\nSEGMENTATION   \\n \\nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \\nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\\n\\nQuestion: what is Hierarchical Page table?\\nHelpful Answer:\"]", "mlflow.spanOutputs": "{\"generations\": [[{\"text\": \" Hierarchical Page table is a memory management scheme that is used when the number of pages is very high. It divides the page table into multiple levels to reduce its size and make it more efficient. This is commonly used in two-level paging architectures.\", \"generation_info\": {\"finish_reason\": \"stop\", \"logprobs\": null}, \"type\": \"Generation\"}]], \"llm_output\": {\"token_usage\": {\"total_tokens\": 1569, \"completion_tokens\": 49, \"prompt_tokens\": 1520}, \"model_name\": \"gpt-3.5-turbo-instruct\"}, \"run\": null}"}, "events": []}], "request": "{\"query\": \"what is Hierarchical Page table?\"}", "response": "{\"result\": \" Hierarchical Page table is a memory management scheme that is used when the number of pages is very high. It divides the page table into multiple levels to reduce its size and make it more efficient. This is commonly used in two-level paging architectures.\", \"source_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 59}, \"page_content\": \"Page  61                       \\n \\n \\nAddress  translation  scheme  for a two-level  paging  architecture:  \\n \\n2. Hashed  Page  Tables:  This  scheme  is applicable  for address  space  larger  than  32bits.  In \\nthis scheme, the virtual page number is hashed into a page table. This page table  contains a  \\nchain of elements hashing to the same location. Virtual page numbers are compared in this  \\nchain  searching  for a match.  If a match  is found,  the corresponding  physical  frame  is \\nextracted.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 60}, \"page_content\": \"Page  62      \\n   \\n \\n3. Inverted  Page  Table : \\n\\uf0de One  entry  for each  real  page  of memory.  \\n\\uf0de Entry  consists  of the virtual  address  of the page  stored  in that  real  memory  location,  with  \\ninformation  about  the process  that  owns  that  page.  \\n\\uf0de Decreases  memory  needed  to store  each  page  table,  but increases  time  needed  to search  \\nthe table  when  a page  reference  occurs.  \\n \\nShared  Pages  \\nShared  code  \\n\\uf0de One  copy  of read -only  (reentrant)  code  shared  among  processes  (i.e.,  text  editors,  \\ncompilers,  window  systems).  \\n\\uf0de Shared  code  must  appear  in same  location  in the logical  address  space  of all processes.  \\nPrivate  code  and  data  \\n\\uf0de Each  process  keeps  a separate  copy  of the code  and data.  \\n\\uf0de The  pages  for the private  code  and data  can appear  anywhere  in the logical  address  space.  \\n \\nSEGMENTATION   \\n \\nSegmentation  is a memory -management  scheme  that  supports  user  view  of memory.  A \\nprogram  is a collection  of segments.  A segment  is a logical  unit  such  as: main  program,\", \"type\": \"Document\"}]}"}