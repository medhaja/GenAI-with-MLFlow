{"spans": [{"name": "RetrievalQA", "context": {"span_id": "0xfc9f64fd3b15d964", "trace_id": "0x639a59c8451fad34ee667d26cb3e9b29"}, "parent_id": null, "start_time": 1723665976301470900, "end_time": 1723665977385306700, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"10b8584c103d48b9a1e4ee989605edc5\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"query\": \"How to log_table()?\"}", "mlflow.spanOutputs": "{\"result\": \" I don't know.\", \"source_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 61}, \"page_content\": \"Page  63                       \\nprocedure, function, method, object, local variables, global variables, common block, stack,  \\nsymbol  table,  arrays  etc. \\nA logical -address space is a collection of segments. Each segment has a name and a  \\nlength. The user specifies each address by two quantities: a segment name/number and an  \\noffset.  \\nHence, Logical address consists of a two tuple:  <segment -number, offset>  \\nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \\nbase  \\u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \\nlimit  \\u2013 specifies  the length  of the segment.  \\nSegment -table  base  register  (STBR)  points  to the segment  table\\u2019s  location  in memory.  \\nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \\n \\n \\n(Diagram  of Segmentation  Hardware)  \\n \\nThe segment number is used as an index into the segment table. The offset d of the  \\nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \\nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \\nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \\nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \\nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \\nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \\n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \\nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 11}, \"page_content\": \"Page  11                       \\n \\n \\nI/O Structure  \\nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \\n\\u2726 Wait instruction  idles the CPU until the next interrupt  \\n\\u2726 Wait loop (contention  for memory  access).  \\n\\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \\nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \\n\\u2726 System  call \\u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \\n\\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \\n\\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \\ninterrupt.  \\nTwo I/O Methods  \\nSynchronous  Asynchronous  \\n \\n \\nDevice -Status  Table\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}]}"}, "events": []}, {"name": "VectorStoreRetriever", "context": {"span_id": "0xe04a2a7e395a5027", "trace_id": "0x639a59c8451fad34ee667d26cb3e9b29"}, "parent_id": "0xfc9f64fd3b15d964", "start_time": 1723665976324470700, "end_time": 1723665976748844300, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"10b8584c103d48b9a1e4ee989605edc5\"", "mlflow.spanType": "\"RETRIEVER\"", "metadata": "{\"ls_retriever_name\": \"vectorstore\", \"ls_vector_store_provider\": \"FAISS\", \"ls_embedding_provider\": \"OpenAIEmbeddings\"}", "mlflow.spanInputs": "\"How to log_table()?\"", "mlflow.spanOutputs": "[{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 61}, \"page_content\": \"Page  63                       \\nprocedure, function, method, object, local variables, global variables, common block, stack,  \\nsymbol  table,  arrays  etc. \\nA logical -address space is a collection of segments. Each segment has a name and a  \\nlength. The user specifies each address by two quantities: a segment name/number and an  \\noffset.  \\nHence, Logical address consists of a two tuple:  <segment -number, offset>  \\nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \\nbase  \\u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \\nlimit  \\u2013 specifies  the length  of the segment.  \\nSegment -table  base  register  (STBR)  points  to the segment  table\\u2019s  location  in memory.  \\nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \\n \\n \\n(Diagram  of Segmentation  Hardware)  \\n \\nThe segment number is used as an index into the segment table. The offset d of the  \\nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \\nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \\nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \\nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \\nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \\nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \\n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \\nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 11}, \"page_content\": \"Page  11                       \\n \\n \\nI/O Structure  \\nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \\n\\u2726 Wait instruction  idles the CPU until the next interrupt  \\n\\u2726 Wait loop (contention  for memory  access).  \\n\\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \\nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \\n\\u2726 System  call \\u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \\n\\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \\n\\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \\ninterrupt.  \\nTwo I/O Methods  \\nSynchronous  Asynchronous  \\n \\n \\nDevice -Status  Table\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}]"}, "events": []}, {"name": "StuffDocumentsChain", "context": {"span_id": "0x47bd7746c2dd251e", "trace_id": "0x639a59c8451fad34ee667d26cb3e9b29"}, "parent_id": "0xfc9f64fd3b15d964", "start_time": 1723665976750354100, "end_time": 1723665977385306700, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"10b8584c103d48b9a1e4ee989605edc5\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"input_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 61}, \"page_content\": \"Page  63                       \\nprocedure, function, method, object, local variables, global variables, common block, stack,  \\nsymbol  table,  arrays  etc. \\nA logical -address space is a collection of segments. Each segment has a name and a  \\nlength. The user specifies each address by two quantities: a segment name/number and an  \\noffset.  \\nHence, Logical address consists of a two tuple:  <segment -number, offset>  \\nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \\nbase  \\u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \\nlimit  \\u2013 specifies  the length  of the segment.  \\nSegment -table  base  register  (STBR)  points  to the segment  table\\u2019s  location  in memory.  \\nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \\n \\n \\n(Diagram  of Segmentation  Hardware)  \\n \\nThe segment number is used as an index into the segment table. The offset d of the  \\nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \\nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \\nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \\nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \\nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \\nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \\n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \\nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 11}, \"page_content\": \"Page  11                       \\n \\n \\nI/O Structure  \\nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \\n\\u2726 Wait instruction  idles the CPU until the next interrupt  \\n\\u2726 Wait loop (contention  for memory  access).  \\n\\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \\nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \\n\\u2726 System  call \\u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \\n\\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \\n\\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \\ninterrupt.  \\nTwo I/O Methods  \\nSynchronous  Asynchronous  \\n \\n \\nDevice -Status  Table\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}], \"question\": \"How to log_table()?\"}", "mlflow.spanOutputs": "{\"output_text\": \" I don't know.\"}"}, "events": []}, {"name": "LLMChain", "context": {"span_id": "0x162886a40c63bd2c", "trace_id": "0x639a59c8451fad34ee667d26cb3e9b29"}, "parent_id": "0x47bd7746c2dd251e", "start_time": 1723665976752212900, "end_time": 1723665977385306700, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"10b8584c103d48b9a1e4ee989605edc5\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"question\": \"How to log_table()?\", \"context\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\\n\\nPage  63                       \\nprocedure, function, method, object, local variables, global variables, common block, stack,  \\nsymbol  table,  arrays  etc. \\nA logical -address space is a collection of segments. Each segment has a name and a  \\nlength. The user specifies each address by two quantities: a segment name/number and an  \\noffset.  \\nHence, Logical address consists of a two tuple:  <segment -number, offset>  \\nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \\nbase  \\u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \\nlimit  \\u2013 specifies  the length  of the segment.  \\nSegment -table  base  register  (STBR)  points  to the segment  table\\u2019s  location  in memory.  \\nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \\n \\n \\n(Diagram  of Segmentation  Hardware)  \\n \\nThe segment number is used as an index into the segment table. The offset d of the  \\nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \\nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \\nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \\nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \\nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \\nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \\n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \\nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\\n\\nPage  11                       \\n \\n \\nI/O Structure  \\nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \\n\\u2726 Wait instruction  idles the CPU until the next interrupt  \\n\\u2726 Wait loop (contention  for memory  access).  \\n\\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \\nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \\n\\u2726 System  call \\u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \\n\\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \\n\\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \\ninterrupt.  \\nTwo I/O Methods  \\nSynchronous  Asynchronous  \\n \\n \\nDevice -Status  Table\\n\\nPage  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\"}", "mlflow.spanOutputs": "{\"text\": \" I don't know.\"}"}, "events": [{"name": "text", "timestamp": 1723665976752213, "attributes": {"text": "Prompt after formatting:\n\u001b[32;1m\u001b[1;3mUse the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n\nPage  58                       \n \n \nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \n \nExample:  \nConsider  a page  size  of 4 bytes  and  a \nphysical memory of  32 bytes (8 pages), we  \nshow how the user's view of memory can  \nbe mapped into physical memory. Logical  \naddress 0 is page 0, offset 0. Indexing into  \nthe page table, we find that page 0 is in  \nframe 5. Thus, logical address 0 maps to  \nphysical  address  20 (= (5 x 4) + 0). Logical  \naddress   3   (page   0,   offset   3)   maps   to \nphysical  address  23 (= (5 x 4) + 3). Logical  \naddress 4 is page 1, offset 0; according to  \nthe page  table,  page  1 is mapped  to frame  \n6. Thus, logical address 4 maps to physical  \naddress  24 (= (6 x 4) + 0). Logical  address  \n13 maps  to physical  address  9(= (2 x 4)+1).  \n \n \n \n \n \n \nHardware  Support  for Paging:                                                                                                       \nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \nhardware  page  table  values  from  the stored  user  page  table.  \nImplementation  of Page  Table  \n\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \n\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \npage  table  and  one for the data/instruction.  \n\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \nPaging  Hardware  With  TLB  \nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\n\nPage  63                       \nprocedure, function, method, object, local variables, global variables, common block, stack,  \nsymbol  table,  arrays  etc. \nA logical -address space is a collection of segments. Each segment has a name and a  \nlength. The user specifies each address by two quantities: a segment name/number and an  \noffset.  \nHence, Logical address consists of a two tuple:  <segment -number, offset>  \nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \nbase  \u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \nlimit  \u2013 specifies  the length  of the segment.  \nSegment -table  base  register  (STBR)  points  to the segment  table\u2019s  location  in memory.  \nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \n \n \n(Diagram  of Segmentation  Hardware)  \n \nThe segment number is used as an index into the segment table. The offset d of the  \nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\n\nPage  11                       \n \n \nI/O Structure  \nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \n\u2726 Wait instruction  idles the CPU until the next interrupt  \n\u2726 Wait loop (contention  for memory  access).  \n\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \n\u2726 System  call \u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \n\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \n\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \ninterrupt.  \nTwo I/O Methods  \nSynchronous  Asynchronous  \n \n \nDevice -Status  Table\n\nPage  60                       \n\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \nis set to \"valid,\" this value indicates that the associated page is in the process' logical - \naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \"invalid,\"  this  value  indicates  \nthat  the page  is not in the process'  logical -address  space.  \n\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \nbit for each  page  to allow  or disallow  accesses  to that  page.  \n \n(Valid  (v) or invalid  (i) bit in a page  table)  \n \nStructure  of the Page Table   \n \nThere  are different  structures  of page  table  described  as follows:  \n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \na logical  address  is as follows:  \n \nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \nthe outer  page  table.  \nTwo -Level  Page -Table  Scheme:\n\nQuestion: How to log_table()?\nHelpful Answer:\u001b[0m"}}]}, {"name": "OpenAI", "context": {"span_id": "0x41faa17dc07697ba", "trace_id": "0x639a59c8451fad34ee667d26cb3e9b29"}, "parent_id": "0x162886a40c63bd2c", "start_time": 1723665976752888200, "end_time": 1723665977384306700, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"10b8584c103d48b9a1e4ee989605edc5\"", "mlflow.spanType": "\"LLM\"", "invocation_params": "{\"model_name\": \"gpt-3.5-turbo-instruct\", \"temperature\": 0.0, \"top_p\": 1.0, \"frequency_penalty\": 0.0, \"presence_penalty\": 0.0, \"n\": 1, \"logit_bias\": {}, \"max_tokens\": 256, \"_type\": \"openai\", \"stop\": null}", "options": "{\"stop\": null}", "batch_size": "1", "mlflow.spanInputs": "[\"Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\\n\\nPage  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\\n\\nPage  63                       \\nprocedure, function, method, object, local variables, global variables, common block, stack,  \\nsymbol  table,  arrays  etc. \\nA logical -address space is a collection of segments. Each segment has a name and a  \\nlength. The user specifies each address by two quantities: a segment name/number and an  \\noffset.  \\nHence, Logical address consists of a two tuple:  <segment -number, offset>  \\nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \\nbase  \\u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \\nlimit  \\u2013 specifies  the length  of the segment.  \\nSegment -table  base  register  (STBR)  points  to the segment  table\\u2019s  location  in memory.  \\nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \\n \\n \\n(Diagram  of Segmentation  Hardware)  \\n \\nThe segment number is used as an index into the segment table. The offset d of the  \\nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \\nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \\nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \\nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \\nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \\nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \\n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \\nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\\n\\nPage  11                       \\n \\n \\nI/O Structure  \\nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \\n\\u2726 Wait instruction  idles the CPU until the next interrupt  \\n\\u2726 Wait loop (contention  for memory  access).  \\n\\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \\nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \\n\\u2726 System  call \\u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \\n\\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \\n\\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \\ninterrupt.  \\nTwo I/O Methods  \\nSynchronous  Asynchronous  \\n \\n \\nDevice -Status  Table\\n\\nPage  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\\n\\nQuestion: How to log_table()?\\nHelpful Answer:\"]", "mlflow.spanOutputs": "{\"generations\": [[{\"text\": \" I don't know.\", \"generation_info\": {\"finish_reason\": \"stop\", \"logprobs\": null}, \"type\": \"Generation\"}]], \"llm_output\": {\"token_usage\": {\"total_tokens\": 1748, \"completion_tokens\": 5, \"prompt_tokens\": 1743}, \"model_name\": \"gpt-3.5-turbo-instruct\"}, \"run\": null}"}, "events": []}], "request": "{\"query\": \"How to log_table()?\"}", "response": "{\"result\": \" I don't know.\", \"source_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 56}, \"page_content\": \"Page  58                       \\n \\n \\nWhere  p is an index  into  the page  table  and  d is the displacement  within  the page.  \\n \\nExample:  \\nConsider  a page  size  of 4 bytes  and  a \\nphysical memory of  32 bytes (8 pages), we  \\nshow how the user's view of memory can  \\nbe mapped into physical memory. Logical  \\naddress 0 is page 0, offset 0. Indexing into  \\nthe page table, we find that page 0 is in  \\nframe 5. Thus, logical address 0 maps to  \\nphysical  address  20 (= (5 x 4) + 0). Logical  \\naddress   3   (page   0,   offset   3)   maps   to \\nphysical  address  23 (= (5 x 4) + 3). Logical  \\naddress 4 is page 1, offset 0; according to  \\nthe page  table,  page  1 is mapped  to frame  \\n6. Thus, logical address 4 maps to physical  \\naddress  24 (= (6 x 4) + 0). Logical  address  \\n13 maps  to physical  address  9(= (2 x 4)+1).  \\n \\n \\n \\n \\n \\n \\nHardware  Support  for Paging:                                                                                                       \\nEach  operating  system  has its own  methods  for storing  page  tables.  Most  operating  \\nsystems  allocate  a page  table  for each  process.  A pointer  to the page  table  is stored  with  the \\nother  register  values  (like  the instruction  counter)  in the process  control  block.  When  the \\ndispatcher  is told  to start  a process,  it must  reload  the user  registers  and define  the correct  \\nhardware  page  table  values  from  the stored  user  page  table.  \\nImplementation  of Page  Table  \\n\\uf0de Generally,  Page  table  is kept  in main  memory.  The  Page  Table  Base  Register  (PTBR)  points  \\nto the page  table.  And  Page -table  length  register  (PRLR)  indicates  size  of the page  table.  \\n\\uf0de In this  scheme  every  data/instruction  access  requires  two  memory  accesses.  One  for the \\npage  table  and  one for the data/instruction.  \\n\\uf0de The two memory  access  problem  can be solved  by the use of a special  fast-lookup  \\nhardware  cache  called  associative  memory  or translation  look -aside  buffers  (TLBs) . \\nPaging  Hardware  With  TLB  \\nThe TLB is an associative and high -speed memory. Each entry in the TLB consists of two  \\nparts: a key  (or tag)  and  a value. The TLB  is used  with  page  tables  in the following  way.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 61}, \"page_content\": \"Page  63                       \\nprocedure, function, method, object, local variables, global variables, common block, stack,  \\nsymbol  table,  arrays  etc. \\nA logical -address space is a collection of segments. Each segment has a name and a  \\nlength. The user specifies each address by two quantities: a segment name/number and an  \\noffset.  \\nHence, Logical address consists of a two tuple:  <segment -number, offset>  \\nSegment  table  maps  two -dimensional  physical  addresses  and  each  entry  in table  has:  \\nbase  \\u2013 contains  the starting  physical  address  where  the segments  reside  in memory.  \\nlimit  \\u2013 specifies  the length  of the segment.  \\nSegment -table  base  register  (STBR)  points  to the segment  table\\u2019s  location  in memory.  \\nSegment -table  length  register  (STLR)  indicates  number  of segments  used  by a program.  \\n \\n \\n(Diagram  of Segmentation  Hardware)  \\n \\nThe segment number is used as an index into the segment table. The offset d of the  \\nlogical address must be between 0 and the segment limit. If it is not, we trap to the operating  \\nsystem that logical addressing attempt beyond end of segment. If this offset is legal, it is  \\nadded  to the segment  base  to produce  the address  in physical  memory  of the desired  byte.  \\nConsider  we have  five segments  numbered  from  0 through  4. The segments  are stored  \\nin physical  memory  as shown  in figure.  The segment  table  has a separate  entry  for each  \\nsegment,  giving  start address  in physical  memory  (or base)  and the length  of that  segment  \\n(or limit).  For example,  segment  2 is 400  bytes  long  and begins  at location  4300.  Thus,  a \\nreference  to byte  53 of segment  2 is mapped  onto  location  4300  + 53 = 4353.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 11}, \"page_content\": \"Page  11                       \\n \\n \\nI/O Structure  \\nAfter  I/O starts,  control  returns  to user program  only upon  I/O completion.  \\n\\u2726 Wait instruction  idles the CPU until the next interrupt  \\n\\u2726 Wait loop (contention  for memory  access).  \\n\\u2726 At most  one I/O request  is outstanding  at a time,  no simultaneous  I/O processing.  \\nAfter  I/O starts,  control  returns  to user program  without  waiting  for I/O completion.  \\n\\u2726 System  call \\u2013 request  to the operating  system  to allow  user to wait for I/O completion.  \\n\\u2726 Device -status  table  contains  entry  for each  I/O device  indicating  its type,  address,  and state.  \\n\\u2726 Operating system indexes into I/O device table to determine device status and to modify table entry to include  \\ninterrupt.  \\nTwo I/O Methods  \\nSynchronous  Asynchronous  \\n \\n \\nDevice -Status  Table\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 58}, \"page_content\": \"Page  60                       \\n\\uf0de One more bit is attached to each entry in the page table: a valid -invalid bit. When this bit  \\nis set to \\\"valid,\\\" this value indicates that the associated page is in the process' logical - \\naddress  space,  and  is a legal  (or valid)  page.  If the bit is set to \\\"invalid,\\\"  this  value  indicates  \\nthat  the page  is not in the process'  logical -address  space.  \\n\\uf0de Illegal addresses are trapped by using the valid -invalid bit. The operating system sets this  \\nbit for each  page  to allow  or disallow  accesses  to that  page.  \\n \\n(Valid  (v) or invalid  (i) bit in a page  table)  \\n \\nStructure  of the Page Table   \\n \\nThere  are different  structures  of page  table  described  as follows:  \\n1. Hierarchical Page table:   When the number of pages is very high, then the page table  \\ntakes  large  amount  of memory  space.  In such  cases,  we use multilevel  paging  scheme  for \\nreducing  size of page  table.  A simple  technique  is a two -level  page  table.  Since  the page  table  \\nis paged,  the page  number  is further  divided  into  parts:  page  number  and page  offset.  Thus,  \\na logical  address  is as follows:  \\n \\nWhere p i is an index into the outer page table, and p2 is the displacement within the page of  \\nthe outer  page  table.  \\nTwo -Level  Page -Table  Scheme:\", \"type\": \"Document\"}]}"}