{"spans": [{"name": "RetrievalQA", "context": {"span_id": "0x52cb6d8a4f34c691", "trace_id": "0xbea8e756ecbba8cb52c33ea672162ee7"}, "parent_id": null, "start_time": 1724012317009793300, "end_time": 1724012318870011800, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"527063ab150748f482c85ac5ed80b7df\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"query\": \"How to prevent Deadlock?\"}", "mlflow.spanOutputs": "{\"result\": \" There are four strategies for preventing deadlock: deadlock prevention, deadlock avoidance, deadlock detection and recovery, and the ostrich approach. Deadlock prevention involves negating at least one of the four necessary conditions for deadlock to occur. Deadlock avoidance involves carefully scheduling resources to avoid deadlock. Deadlock detection and recovery involves detecting and recovering from deadlock when it occurs. The ostrich approach involves ignoring the deadlock problem altogether.\", \"source_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 45}, \"page_content\": \"Page  47                       \\n \\n \\n \\nResource  Allocation  Graph  with a Cycle  but No Deadlock  \\n \\n \\nMETHODS  OF HANDLING  DEADLOCK  \\n \\nIn general,  there  are four strategies  of dealing  with deadlock problem:  \\n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \\nconditions.  \\n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \\n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \\n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \\n \\nDEADLOCK  PREVENTION  \\n \\nA deadlock may  be prevented  by denying  any one of the conditions.  \\n\\uf0b7 Elimination of \\u201cMutual Exclusion\\u201d Condition:  The mutual exclusion condition must hold for non - \\nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \\ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \\ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \\nexclusive  access and thus  cannot  be involved  in deadlock. \\uf020\\n\\uf0b7 Elimination of \\u201cHold and Wait\\u201d Condition:  There are two possibilities for elimination of the second  \\ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \\nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \\nhas previously allocated resources. This strategy requires that all of the resources a process will need  \\nmust be requested at once. The system must grant resources on \\u201call or none\\u201d basis. If the complete set  \\nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \\ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \\n\\u201cwait for\\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \\nresources. \\uf020\\n\\uf0b7 Elimination of \\u201cNo -preemption\\u201d Condition:  The non -preemption condition can be alleviated by forcing  \\na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \\nresources, so that other processes may use them to finish. This strategy requires that when a process  \\nthat is holding some resources is denied a request for additio nal resources. The process must release its  \\nheld resources and, if necessary, request them again together with additional resources. Implementation  \\nof this strategy  denies the  \\u201cno-preemptive\\u201d condition  effectively. \\uf020\\n\\uf0b7 Elimination of \\u201cCircular Wait\\u201d Condition:  The last condition, the circular wait, can be denied by  \\nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \\nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \\ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \\ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 43}, \"page_content\": \"Page  45                       \\nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \\nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \\nresources held  by the process . \\n \\nResource -Allocation  Graph  \\n \\n \\ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \\n \\nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \\ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \\nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \\nA directed edge from process Pi to resource type Rj is denoted by Pi \\uf0e0Rj; it signifies that process Pi  \\nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \\uf0e0Rj is \\ncalled  a request  edge.  \\nA directed edge from resource type Rj to process Pi is denoted by Rj \\uf0e0Pi; it signifies that an instance of  \\nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\\uf0e0Pi is called  an assignment  edge.  \\nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \\nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \\nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \\nsquare.  \\n \\n \\nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \\nThe sets P, R, and  E: \\nP={P1,P2,P3}  \\nR={R1,R2,R3,R4}  \\nE={P1\\uf0aeR1, P2\\uf0aeR3, R1\\uf0aeP2, R2\\uf0aeP2, R2\\uf0aeP1, R3\\uf0aeP3} \\nResource  instances:  \\n\\uf0b7 One instance  of resource  type R1\\uf020\\n\\uf0b7 Two instances  of resource  type R2\\uf020\\n\\uf0b7 One instance  of resource  type R3\\uf020\\n\\uf0b7 Three  instances  of resource  type R4\\uf020\\nProcess  states:  \\n\\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \\nR1.\\uf020\\n\\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\\uf020\\n\\uf0b7 Process  P3 is holding  an instance  of R3.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 46}, \"page_content\": \"Page  48                       \\nFor example,  provide  a global  numbering  of all the resources,  as shown  \\n1 \\u2261 Card  reader  \\n2 \\u2261 Printer  \\n3 \\u2261 Optical  driver  \\n4 \\u2261 HDD  \\n5 \\u2261 Card  punch  \\nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \\nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \\nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \\nimpossible  to find an ordering  that satisfies everyone.  \\n \\nDEADLOCK  AVOIDANCE  \\n \\nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \\nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \\nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \\nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\\u2019s  algorithm.  \\nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \\ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \\nallocated  resources,  and the maximum  demands of the  processes.  \\n \\nSafe and Unsafe  States  \\n \\nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \\nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \\nresources  are immediately  granted  if the resource  is available.  \\nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \\nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \\ndeadlocked.  \\n \\n \\n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \\n \\n \\nResource -Allocation  Graph  Algorithm  \\n \\nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \\nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \\uf0e0Rj indicates that process Pi may  \\nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \\nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \\uf0e0Rj is converted to a  \\nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \\uf0e0Pi is reconverted to a  \\nclaim  edge  Pi\\uf0e0 Rj.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 42}, \"page_content\": \"Page  44                       \\nLecture  #25 \\n \\nDeadlocks  \\n \\nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \\ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \\nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \\nthem  can release any  resources,  and none  of them  can be awakened.  \\nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \\nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \\nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \\n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \\nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \\nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \\nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \\nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \\n \\nPreemptable  and  Nonpreemptable  Resources  \\nResources  come  in two flavors:  preemptable  and nonpreemptable.  \\n\\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \\nexample  of a preemptable  resource.  \\n\\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \\nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \\n\\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \\ninvolve nonpreemptable  resources  are difficult  to deal with. \\nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \\n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \\ncan acquire  the resource.  \\n2. Use:  The process  can operate  on the resource.  \\n3. Release:  The process  releases  the resource.  \\nNecessary  Conditions  for Deadlock  \\n \\nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \\n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \\nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \\ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \\nprocess  must  be delayed  until the resource  has been  released.  \\n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \\nresources.  \\nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \\nadditional  resource  that are currently  being  held by other processes.  \\n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \\nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \\nvoluntarily  by the process holding  it. \\n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \\nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \\u2026, P0} of  \\nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \\nheld by P2, \\u2026, Pn\\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \\nby P0. \\nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \\n\\u201chold -and-wait\\u201d  condition  between  two or more  processes,  so \\u201cone\\u201d  process  cannot  hold a resource,  yet be\", \"type\": \"Document\"}]}"}, "events": []}, {"name": "VectorStoreRetriever", "context": {"span_id": "0x4af5ad723dda1728", "trace_id": "0xbea8e756ecbba8cb52c33ea672162ee7"}, "parent_id": "0x52cb6d8a4f34c691", "start_time": 1724012317030453000, "end_time": 1724012317382139400, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"527063ab150748f482c85ac5ed80b7df\"", "mlflow.spanType": "\"RETRIEVER\"", "metadata": "{\"ls_retriever_name\": \"vectorstore\", \"ls_vector_store_provider\": \"FAISS\", \"ls_embedding_provider\": \"OpenAIEmbeddings\"}", "mlflow.spanInputs": "\"How to prevent Deadlock?\"", "mlflow.spanOutputs": "[{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 45}, \"page_content\": \"Page  47                       \\n \\n \\n \\nResource  Allocation  Graph  with a Cycle  but No Deadlock  \\n \\n \\nMETHODS  OF HANDLING  DEADLOCK  \\n \\nIn general,  there  are four strategies  of dealing  with deadlock problem:  \\n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \\nconditions.  \\n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \\n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \\n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \\n \\nDEADLOCK  PREVENTION  \\n \\nA deadlock may  be prevented  by denying  any one of the conditions.  \\n\\uf0b7 Elimination of \\u201cMutual Exclusion\\u201d Condition:  The mutual exclusion condition must hold for non - \\nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \\ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \\ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \\nexclusive  access and thus  cannot  be involved  in deadlock. \\uf020\\n\\uf0b7 Elimination of \\u201cHold and Wait\\u201d Condition:  There are two possibilities for elimination of the second  \\ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \\nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \\nhas previously allocated resources. This strategy requires that all of the resources a process will need  \\nmust be requested at once. The system must grant resources on \\u201call or none\\u201d basis. If the complete set  \\nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \\ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \\n\\u201cwait for\\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \\nresources. \\uf020\\n\\uf0b7 Elimination of \\u201cNo -preemption\\u201d Condition:  The non -preemption condition can be alleviated by forcing  \\na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \\nresources, so that other processes may use them to finish. This strategy requires that when a process  \\nthat is holding some resources is denied a request for additio nal resources. The process must release its  \\nheld resources and, if necessary, request them again together with additional resources. Implementation  \\nof this strategy  denies the  \\u201cno-preemptive\\u201d condition  effectively. \\uf020\\n\\uf0b7 Elimination of \\u201cCircular Wait\\u201d Condition:  The last condition, the circular wait, can be denied by  \\nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \\nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \\ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \\ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 43}, \"page_content\": \"Page  45                       \\nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \\nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \\nresources held  by the process . \\n \\nResource -Allocation  Graph  \\n \\n \\ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \\n \\nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \\ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \\nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \\nA directed edge from process Pi to resource type Rj is denoted by Pi \\uf0e0Rj; it signifies that process Pi  \\nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \\uf0e0Rj is \\ncalled  a request  edge.  \\nA directed edge from resource type Rj to process Pi is denoted by Rj \\uf0e0Pi; it signifies that an instance of  \\nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\\uf0e0Pi is called  an assignment  edge.  \\nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \\nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \\nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \\nsquare.  \\n \\n \\nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \\nThe sets P, R, and  E: \\nP={P1,P2,P3}  \\nR={R1,R2,R3,R4}  \\nE={P1\\uf0aeR1, P2\\uf0aeR3, R1\\uf0aeP2, R2\\uf0aeP2, R2\\uf0aeP1, R3\\uf0aeP3} \\nResource  instances:  \\n\\uf0b7 One instance  of resource  type R1\\uf020\\n\\uf0b7 Two instances  of resource  type R2\\uf020\\n\\uf0b7 One instance  of resource  type R3\\uf020\\n\\uf0b7 Three  instances  of resource  type R4\\uf020\\nProcess  states:  \\n\\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \\nR1.\\uf020\\n\\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\\uf020\\n\\uf0b7 Process  P3 is holding  an instance  of R3.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 46}, \"page_content\": \"Page  48                       \\nFor example,  provide  a global  numbering  of all the resources,  as shown  \\n1 \\u2261 Card  reader  \\n2 \\u2261 Printer  \\n3 \\u2261 Optical  driver  \\n4 \\u2261 HDD  \\n5 \\u2261 Card  punch  \\nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \\nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \\nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \\nimpossible  to find an ordering  that satisfies everyone.  \\n \\nDEADLOCK  AVOIDANCE  \\n \\nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \\nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \\nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \\nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\\u2019s  algorithm.  \\nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \\ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \\nallocated  resources,  and the maximum  demands of the  processes.  \\n \\nSafe and Unsafe  States  \\n \\nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \\nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \\nresources  are immediately  granted  if the resource  is available.  \\nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \\nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \\ndeadlocked.  \\n \\n \\n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \\n \\n \\nResource -Allocation  Graph  Algorithm  \\n \\nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \\nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \\uf0e0Rj indicates that process Pi may  \\nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \\nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \\uf0e0Rj is converted to a  \\nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \\uf0e0Pi is reconverted to a  \\nclaim  edge  Pi\\uf0e0 Rj.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 42}, \"page_content\": \"Page  44                       \\nLecture  #25 \\n \\nDeadlocks  \\n \\nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \\ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \\nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \\nthem  can release any  resources,  and none  of them  can be awakened.  \\nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \\nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \\nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \\n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \\nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \\nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \\nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \\nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \\n \\nPreemptable  and  Nonpreemptable  Resources  \\nResources  come  in two flavors:  preemptable  and nonpreemptable.  \\n\\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \\nexample  of a preemptable  resource.  \\n\\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \\nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \\n\\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \\ninvolve nonpreemptable  resources  are difficult  to deal with. \\nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \\n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \\ncan acquire  the resource.  \\n2. Use:  The process  can operate  on the resource.  \\n3. Release:  The process  releases  the resource.  \\nNecessary  Conditions  for Deadlock  \\n \\nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \\n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \\nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \\ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \\nprocess  must  be delayed  until the resource  has been  released.  \\n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \\nresources.  \\nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \\nadditional  resource  that are currently  being  held by other processes.  \\n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \\nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \\nvoluntarily  by the process holding  it. \\n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \\nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \\u2026, P0} of  \\nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \\nheld by P2, \\u2026, Pn\\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \\nby P0. \\nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \\n\\u201chold -and-wait\\u201d  condition  between  two or more  processes,  so \\u201cone\\u201d  process  cannot  hold a resource,  yet be\", \"type\": \"Document\"}]"}, "events": []}, {"name": "StuffDocumentsChain", "context": {"span_id": "0xa1c284c191334dd6", "trace_id": "0xbea8e756ecbba8cb52c33ea672162ee7"}, "parent_id": "0x52cb6d8a4f34c691", "start_time": 1724012317384139000, "end_time": 1724012318870011800, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"527063ab150748f482c85ac5ed80b7df\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"input_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 45}, \"page_content\": \"Page  47                       \\n \\n \\n \\nResource  Allocation  Graph  with a Cycle  but No Deadlock  \\n \\n \\nMETHODS  OF HANDLING  DEADLOCK  \\n \\nIn general,  there  are four strategies  of dealing  with deadlock problem:  \\n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \\nconditions.  \\n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \\n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \\n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \\n \\nDEADLOCK  PREVENTION  \\n \\nA deadlock may  be prevented  by denying  any one of the conditions.  \\n\\uf0b7 Elimination of \\u201cMutual Exclusion\\u201d Condition:  The mutual exclusion condition must hold for non - \\nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \\ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \\ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \\nexclusive  access and thus  cannot  be involved  in deadlock. \\uf020\\n\\uf0b7 Elimination of \\u201cHold and Wait\\u201d Condition:  There are two possibilities for elimination of the second  \\ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \\nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \\nhas previously allocated resources. This strategy requires that all of the resources a process will need  \\nmust be requested at once. The system must grant resources on \\u201call or none\\u201d basis. If the complete set  \\nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \\ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \\n\\u201cwait for\\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \\nresources. \\uf020\\n\\uf0b7 Elimination of \\u201cNo -preemption\\u201d Condition:  The non -preemption condition can be alleviated by forcing  \\na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \\nresources, so that other processes may use them to finish. This strategy requires that when a process  \\nthat is holding some resources is denied a request for additio nal resources. The process must release its  \\nheld resources and, if necessary, request them again together with additional resources. Implementation  \\nof this strategy  denies the  \\u201cno-preemptive\\u201d condition  effectively. \\uf020\\n\\uf0b7 Elimination of \\u201cCircular Wait\\u201d Condition:  The last condition, the circular wait, can be denied by  \\nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \\nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \\ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \\ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 43}, \"page_content\": \"Page  45                       \\nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \\nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \\nresources held  by the process . \\n \\nResource -Allocation  Graph  \\n \\n \\ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \\n \\nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \\ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \\nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \\nA directed edge from process Pi to resource type Rj is denoted by Pi \\uf0e0Rj; it signifies that process Pi  \\nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \\uf0e0Rj is \\ncalled  a request  edge.  \\nA directed edge from resource type Rj to process Pi is denoted by Rj \\uf0e0Pi; it signifies that an instance of  \\nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\\uf0e0Pi is called  an assignment  edge.  \\nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \\nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \\nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \\nsquare.  \\n \\n \\nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \\nThe sets P, R, and  E: \\nP={P1,P2,P3}  \\nR={R1,R2,R3,R4}  \\nE={P1\\uf0aeR1, P2\\uf0aeR3, R1\\uf0aeP2, R2\\uf0aeP2, R2\\uf0aeP1, R3\\uf0aeP3} \\nResource  instances:  \\n\\uf0b7 One instance  of resource  type R1\\uf020\\n\\uf0b7 Two instances  of resource  type R2\\uf020\\n\\uf0b7 One instance  of resource  type R3\\uf020\\n\\uf0b7 Three  instances  of resource  type R4\\uf020\\nProcess  states:  \\n\\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \\nR1.\\uf020\\n\\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\\uf020\\n\\uf0b7 Process  P3 is holding  an instance  of R3.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 46}, \"page_content\": \"Page  48                       \\nFor example,  provide  a global  numbering  of all the resources,  as shown  \\n1 \\u2261 Card  reader  \\n2 \\u2261 Printer  \\n3 \\u2261 Optical  driver  \\n4 \\u2261 HDD  \\n5 \\u2261 Card  punch  \\nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \\nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \\nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \\nimpossible  to find an ordering  that satisfies everyone.  \\n \\nDEADLOCK  AVOIDANCE  \\n \\nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \\nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \\nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \\nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\\u2019s  algorithm.  \\nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \\ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \\nallocated  resources,  and the maximum  demands of the  processes.  \\n \\nSafe and Unsafe  States  \\n \\nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \\nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \\nresources  are immediately  granted  if the resource  is available.  \\nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \\nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \\ndeadlocked.  \\n \\n \\n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \\n \\n \\nResource -Allocation  Graph  Algorithm  \\n \\nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \\nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \\uf0e0Rj indicates that process Pi may  \\nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \\nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \\uf0e0Rj is converted to a  \\nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \\uf0e0Pi is reconverted to a  \\nclaim  edge  Pi\\uf0e0 Rj.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 42}, \"page_content\": \"Page  44                       \\nLecture  #25 \\n \\nDeadlocks  \\n \\nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \\ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \\nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \\nthem  can release any  resources,  and none  of them  can be awakened.  \\nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \\nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \\nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \\n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \\nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \\nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \\nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \\nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \\n \\nPreemptable  and  Nonpreemptable  Resources  \\nResources  come  in two flavors:  preemptable  and nonpreemptable.  \\n\\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \\nexample  of a preemptable  resource.  \\n\\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \\nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \\n\\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \\ninvolve nonpreemptable  resources  are difficult  to deal with. \\nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \\n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \\ncan acquire  the resource.  \\n2. Use:  The process  can operate  on the resource.  \\n3. Release:  The process  releases  the resource.  \\nNecessary  Conditions  for Deadlock  \\n \\nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \\n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \\nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \\ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \\nprocess  must  be delayed  until the resource  has been  released.  \\n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \\nresources.  \\nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \\nadditional  resource  that are currently  being  held by other processes.  \\n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \\nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \\nvoluntarily  by the process holding  it. \\n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \\nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \\u2026, P0} of  \\nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \\nheld by P2, \\u2026, Pn\\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \\nby P0. \\nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \\n\\u201chold -and-wait\\u201d  condition  between  two or more  processes,  so \\u201cone\\u201d  process  cannot  hold a resource,  yet be\", \"type\": \"Document\"}], \"question\": \"How to prevent Deadlock?\"}", "mlflow.spanOutputs": "{\"output_text\": \" There are four strategies for preventing deadlock: deadlock prevention, deadlock avoidance, deadlock detection and recovery, and the ostrich approach. Deadlock prevention involves negating at least one of the four necessary conditions for deadlock to occur. Deadlock avoidance involves carefully scheduling resources to avoid deadlock. Deadlock detection and recovery involves detecting and recovering from deadlock when it occurs. The ostrich approach involves ignoring the deadlock problem altogether.\"}"}, "events": []}, {"name": "LLMChain", "context": {"span_id": "0xf799790d02662a4c", "trace_id": "0xbea8e756ecbba8cb52c33ea672162ee7"}, "parent_id": "0xa1c284c191334dd6", "start_time": 1724012317387147800, "end_time": 1724012318868619500, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"527063ab150748f482c85ac5ed80b7df\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"question\": \"How to prevent Deadlock?\", \"context\": \"Page  47                       \\n \\n \\n \\nResource  Allocation  Graph  with a Cycle  but No Deadlock  \\n \\n \\nMETHODS  OF HANDLING  DEADLOCK  \\n \\nIn general,  there  are four strategies  of dealing  with deadlock problem:  \\n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \\nconditions.  \\n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \\n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \\n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \\n \\nDEADLOCK  PREVENTION  \\n \\nA deadlock may  be prevented  by denying  any one of the conditions.  \\n\\uf0b7 Elimination of \\u201cMutual Exclusion\\u201d Condition:  The mutual exclusion condition must hold for non - \\nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \\ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \\ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \\nexclusive  access and thus  cannot  be involved  in deadlock. \\uf020\\n\\uf0b7 Elimination of \\u201cHold and Wait\\u201d Condition:  There are two possibilities for elimination of the second  \\ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \\nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \\nhas previously allocated resources. This strategy requires that all of the resources a process will need  \\nmust be requested at once. The system must grant resources on \\u201call or none\\u201d basis. If the complete set  \\nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \\ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \\n\\u201cwait for\\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \\nresources. \\uf020\\n\\uf0b7 Elimination of \\u201cNo -preemption\\u201d Condition:  The non -preemption condition can be alleviated by forcing  \\na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \\nresources, so that other processes may use them to finish. This strategy requires that when a process  \\nthat is holding some resources is denied a request for additio nal resources. The process must release its  \\nheld resources and, if necessary, request them again together with additional resources. Implementation  \\nof this strategy  denies the  \\u201cno-preemptive\\u201d condition  effectively. \\uf020\\n\\uf0b7 Elimination of \\u201cCircular Wait\\u201d Condition:  The last condition, the circular wait, can be denied by  \\nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \\nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \\ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \\ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\\uf020\\n\\nPage  45                       \\nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \\nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \\nresources held  by the process . \\n \\nResource -Allocation  Graph  \\n \\n \\ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \\n \\nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \\ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \\nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \\nA directed edge from process Pi to resource type Rj is denoted by Pi \\uf0e0Rj; it signifies that process Pi  \\nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \\uf0e0Rj is \\ncalled  a request  edge.  \\nA directed edge from resource type Rj to process Pi is denoted by Rj \\uf0e0Pi; it signifies that an instance of  \\nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\\uf0e0Pi is called  an assignment  edge.  \\nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \\nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \\nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \\nsquare.  \\n \\n \\nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \\nThe sets P, R, and  E: \\nP={P1,P2,P3}  \\nR={R1,R2,R3,R4}  \\nE={P1\\uf0aeR1, P2\\uf0aeR3, R1\\uf0aeP2, R2\\uf0aeP2, R2\\uf0aeP1, R3\\uf0aeP3} \\nResource  instances:  \\n\\uf0b7 One instance  of resource  type R1\\uf020\\n\\uf0b7 Two instances  of resource  type R2\\uf020\\n\\uf0b7 One instance  of resource  type R3\\uf020\\n\\uf0b7 Three  instances  of resource  type R4\\uf020\\nProcess  states:  \\n\\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \\nR1.\\uf020\\n\\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\\uf020\\n\\uf0b7 Process  P3 is holding  an instance  of R3.\\uf020\\n\\nPage  48                       \\nFor example,  provide  a global  numbering  of all the resources,  as shown  \\n1 \\u2261 Card  reader  \\n2 \\u2261 Printer  \\n3 \\u2261 Optical  driver  \\n4 \\u2261 HDD  \\n5 \\u2261 Card  punch  \\nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \\nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \\nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \\nimpossible  to find an ordering  that satisfies everyone.  \\n \\nDEADLOCK  AVOIDANCE  \\n \\nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \\nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \\nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \\nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\\u2019s  algorithm.  \\nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \\ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \\nallocated  resources,  and the maximum  demands of the  processes.  \\n \\nSafe and Unsafe  States  \\n \\nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \\nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \\nresources  are immediately  granted  if the resource  is available.  \\nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \\nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \\ndeadlocked.  \\n \\n \\n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \\n \\n \\nResource -Allocation  Graph  Algorithm  \\n \\nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \\nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \\uf0e0Rj indicates that process Pi may  \\nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \\nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \\uf0e0Rj is converted to a  \\nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \\uf0e0Pi is reconverted to a  \\nclaim  edge  Pi\\uf0e0 Rj.\\n\\nPage  44                       \\nLecture  #25 \\n \\nDeadlocks  \\n \\nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \\ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \\nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \\nthem  can release any  resources,  and none  of them  can be awakened.  \\nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \\nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \\nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \\n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \\nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \\nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \\nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \\nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \\n \\nPreemptable  and  Nonpreemptable  Resources  \\nResources  come  in two flavors:  preemptable  and nonpreemptable.  \\n\\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \\nexample  of a preemptable  resource.  \\n\\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \\nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \\n\\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \\ninvolve nonpreemptable  resources  are difficult  to deal with. \\nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \\n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \\ncan acquire  the resource.  \\n2. Use:  The process  can operate  on the resource.  \\n3. Release:  The process  releases  the resource.  \\nNecessary  Conditions  for Deadlock  \\n \\nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \\n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \\nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \\ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \\nprocess  must  be delayed  until the resource  has been  released.  \\n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \\nresources.  \\nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \\nadditional  resource  that are currently  being  held by other processes.  \\n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \\nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \\nvoluntarily  by the process holding  it. \\n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \\nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \\u2026, P0} of  \\nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \\nheld by P2, \\u2026, Pn\\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \\nby P0. \\nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \\n\\u201chold -and-wait\\u201d  condition  between  two or more  processes,  so \\u201cone\\u201d  process  cannot  hold a resource,  yet be\"}", "mlflow.spanOutputs": "{\"text\": \" There are four strategies for preventing deadlock: deadlock prevention, deadlock avoidance, deadlock detection and recovery, and the ostrich approach. Deadlock prevention involves negating at least one of the four necessary conditions for deadlock to occur. Deadlock avoidance involves carefully scheduling resources to avoid deadlock. Deadlock detection and recovery involves detecting and recovering from deadlock when it occurs. The ostrich approach involves ignoring the deadlock problem altogether.\"}"}, "events": [{"name": "text", "timestamp": 1724012317387147, "attributes": {"text": "Prompt after formatting:\n\u001b[32;1m\u001b[1;3mUse the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n\nPage  47                       \n \n \n \nResource  Allocation  Graph  with a Cycle  but No Deadlock  \n \n \nMETHODS  OF HANDLING  DEADLOCK  \n \nIn general,  there  are four strategies  of dealing  with deadlock problem:  \n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \nconditions.  \n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \n \nDEADLOCK  PREVENTION  \n \nA deadlock may  be prevented  by denying  any one of the conditions.  \n\uf0b7 Elimination of \u201cMutual Exclusion\u201d Condition:  The mutual exclusion condition must hold for non - \nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \nexclusive  access and thus  cannot  be involved  in deadlock. \uf020\n\uf0b7 Elimination of \u201cHold and Wait\u201d Condition:  There are two possibilities for elimination of the second  \ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \nhas previously allocated resources. This strategy requires that all of the resources a process will need  \nmust be requested at once. The system must grant resources on \u201call or none\u201d basis. If the complete set  \nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \n\u201cwait for\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \nresources. \uf020\n\uf0b7 Elimination of \u201cNo -preemption\u201d Condition:  The non -preemption condition can be alleviated by forcing  \na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \nresources, so that other processes may use them to finish. This strategy requires that when a process  \nthat is holding some resources is denied a request for additio nal resources. The process must release its  \nheld resources and, if necessary, request them again together with additional resources. Implementation  \nof this strategy  denies the  \u201cno-preemptive\u201d condition  effectively. \uf020\n\uf0b7 Elimination of \u201cCircular Wait\u201d Condition:  The last condition, the circular wait, can be denied by  \nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\uf020\n\nPage  45                       \nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \nresources held  by the process . \n \nResource -Allocation  Graph  \n \n \ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \n \nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \nA directed edge from process Pi to resource type Rj is denoted by Pi \uf0e0Rj; it signifies that process Pi  \nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \uf0e0Rj is \ncalled  a request  edge.  \nA directed edge from resource type Rj to process Pi is denoted by Rj \uf0e0Pi; it signifies that an instance of  \nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\uf0e0Pi is called  an assignment  edge.  \nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \nsquare.  \n \n \nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \nThe sets P, R, and  E: \nP={P1,P2,P3}  \nR={R1,R2,R3,R4}  \nE={P1\uf0aeR1, P2\uf0aeR3, R1\uf0aeP2, R2\uf0aeP2, R2\uf0aeP1, R3\uf0aeP3} \nResource  instances:  \n\uf0b7 One instance  of resource  type R1\uf020\n\uf0b7 Two instances  of resource  type R2\uf020\n\uf0b7 One instance  of resource  type R3\uf020\n\uf0b7 Three  instances  of resource  type R4\uf020\nProcess  states:  \n\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \nR1.\uf020\n\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\uf020\n\uf0b7 Process  P3 is holding  an instance  of R3.\uf020\n\nPage  48                       \nFor example,  provide  a global  numbering  of all the resources,  as shown  \n1 \u2261 Card  reader  \n2 \u2261 Printer  \n3 \u2261 Optical  driver  \n4 \u2261 HDD  \n5 \u2261 Card  punch  \nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \nimpossible  to find an ordering  that satisfies everyone.  \n \nDEADLOCK  AVOIDANCE  \n \nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\u2019s  algorithm.  \nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \nallocated  resources,  and the maximum  demands of the  processes.  \n \nSafe and Unsafe  States  \n \nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \nresources  are immediately  granted  if the resource  is available.  \nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \ndeadlocked.  \n \n \n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \n \n \nResource -Allocation  Graph  Algorithm  \n \nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \uf0e0Rj indicates that process Pi may  \nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \uf0e0Rj is converted to a  \nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \uf0e0Pi is reconverted to a  \nclaim  edge  Pi\uf0e0 Rj.\n\nPage  44                       \nLecture  #25 \n \nDeadlocks  \n \nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \nthem  can release any  resources,  and none  of them  can be awakened.  \nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \n \nPreemptable  and  Nonpreemptable  Resources  \nResources  come  in two flavors:  preemptable  and nonpreemptable.  \n\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \nexample  of a preemptable  resource.  \n\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \n\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \ninvolve nonpreemptable  resources  are difficult  to deal with. \nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \ncan acquire  the resource.  \n2. Use:  The process  can operate  on the resource.  \n3. Release:  The process  releases  the resource.  \nNecessary  Conditions  for Deadlock  \n \nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \nprocess  must  be delayed  until the resource  has been  released.  \n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \nresources.  \nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \nadditional  resource  that are currently  being  held by other processes.  \n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \nvoluntarily  by the process holding  it. \n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \u2026, P0} of  \nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \nheld by P2, \u2026, Pn\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \nby P0. \nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \n\u201chold -and-wait\u201d  condition  between  two or more  processes,  so \u201cone\u201d  process  cannot  hold a resource,  yet be\n\nQuestion: How to prevent Deadlock?\nHelpful Answer:\u001b[0m"}}]}, {"name": "OpenAI", "context": {"span_id": "0x5cfb0ea52943e7ba", "trace_id": "0xbea8e756ecbba8cb52c33ea672162ee7"}, "parent_id": "0xf799790d02662a4c", "start_time": 1724012317389145000, "end_time": 1724012318868619500, "status_code": "OK", "status_message": "", "attributes": {"mlflow.traceRequestId": "\"527063ab150748f482c85ac5ed80b7df\"", "mlflow.spanType": "\"LLM\"", "invocation_params": "{\"model_name\": \"gpt-3.5-turbo-instruct\", \"temperature\": 0.0, \"top_p\": 1, \"frequency_penalty\": 0, \"presence_penalty\": 0, \"n\": 1, \"logit_bias\": {}, \"max_tokens\": 256, \"_type\": \"openai\", \"stop\": null}", "options": "{\"stop\": null}", "batch_size": "1", "mlflow.spanInputs": "[\"Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\\n\\nPage  47                       \\n \\n \\n \\nResource  Allocation  Graph  with a Cycle  but No Deadlock  \\n \\n \\nMETHODS  OF HANDLING  DEADLOCK  \\n \\nIn general,  there  are four strategies  of dealing  with deadlock problem:  \\n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \\nconditions.  \\n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \\n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \\n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \\n \\nDEADLOCK  PREVENTION  \\n \\nA deadlock may  be prevented  by denying  any one of the conditions.  \\n\\uf0b7 Elimination of \\u201cMutual Exclusion\\u201d Condition:  The mutual exclusion condition must hold for non - \\nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \\ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \\ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \\nexclusive  access and thus  cannot  be involved  in deadlock. \\uf020\\n\\uf0b7 Elimination of \\u201cHold and Wait\\u201d Condition:  There are two possibilities for elimination of the second  \\ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \\nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \\nhas previously allocated resources. This strategy requires that all of the resources a process will need  \\nmust be requested at once. The system must grant resources on \\u201call or none\\u201d basis. If the complete set  \\nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \\ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \\n\\u201cwait for\\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \\nresources. \\uf020\\n\\uf0b7 Elimination of \\u201cNo -preemption\\u201d Condition:  The non -preemption condition can be alleviated by forcing  \\na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \\nresources, so that other processes may use them to finish. This strategy requires that when a process  \\nthat is holding some resources is denied a request for additio nal resources. The process must release its  \\nheld resources and, if necessary, request them again together with additional resources. Implementation  \\nof this strategy  denies the  \\u201cno-preemptive\\u201d condition  effectively. \\uf020\\n\\uf0b7 Elimination of \\u201cCircular Wait\\u201d Condition:  The last condition, the circular wait, can be denied by  \\nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \\nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \\ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \\ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\\uf020\\n\\nPage  45                       \\nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \\nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \\nresources held  by the process . \\n \\nResource -Allocation  Graph  \\n \\n \\ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \\n \\nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \\ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \\nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \\nA directed edge from process Pi to resource type Rj is denoted by Pi \\uf0e0Rj; it signifies that process Pi  \\nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \\uf0e0Rj is \\ncalled  a request  edge.  \\nA directed edge from resource type Rj to process Pi is denoted by Rj \\uf0e0Pi; it signifies that an instance of  \\nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\\uf0e0Pi is called  an assignment  edge.  \\nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \\nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \\nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \\nsquare.  \\n \\n \\nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \\nThe sets P, R, and  E: \\nP={P1,P2,P3}  \\nR={R1,R2,R3,R4}  \\nE={P1\\uf0aeR1, P2\\uf0aeR3, R1\\uf0aeP2, R2\\uf0aeP2, R2\\uf0aeP1, R3\\uf0aeP3} \\nResource  instances:  \\n\\uf0b7 One instance  of resource  type R1\\uf020\\n\\uf0b7 Two instances  of resource  type R2\\uf020\\n\\uf0b7 One instance  of resource  type R3\\uf020\\n\\uf0b7 Three  instances  of resource  type R4\\uf020\\nProcess  states:  \\n\\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \\nR1.\\uf020\\n\\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\\uf020\\n\\uf0b7 Process  P3 is holding  an instance  of R3.\\uf020\\n\\nPage  48                       \\nFor example,  provide  a global  numbering  of all the resources,  as shown  \\n1 \\u2261 Card  reader  \\n2 \\u2261 Printer  \\n3 \\u2261 Optical  driver  \\n4 \\u2261 HDD  \\n5 \\u2261 Card  punch  \\nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \\nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \\nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \\nimpossible  to find an ordering  that satisfies everyone.  \\n \\nDEADLOCK  AVOIDANCE  \\n \\nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \\nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \\nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \\nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\\u2019s  algorithm.  \\nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \\ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \\nallocated  resources,  and the maximum  demands of the  processes.  \\n \\nSafe and Unsafe  States  \\n \\nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \\nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \\nresources  are immediately  granted  if the resource  is available.  \\nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \\nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \\ndeadlocked.  \\n \\n \\n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \\n \\n \\nResource -Allocation  Graph  Algorithm  \\n \\nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \\nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \\uf0e0Rj indicates that process Pi may  \\nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \\nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \\uf0e0Rj is converted to a  \\nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \\uf0e0Pi is reconverted to a  \\nclaim  edge  Pi\\uf0e0 Rj.\\n\\nPage  44                       \\nLecture  #25 \\n \\nDeadlocks  \\n \\nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \\ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \\nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \\nthem  can release any  resources,  and none  of them  can be awakened.  \\nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \\nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \\nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \\n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \\nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \\nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \\nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \\nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \\n \\nPreemptable  and  Nonpreemptable  Resources  \\nResources  come  in two flavors:  preemptable  and nonpreemptable.  \\n\\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \\nexample  of a preemptable  resource.  \\n\\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \\nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \\n\\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \\ninvolve nonpreemptable  resources  are difficult  to deal with. \\nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \\n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \\ncan acquire  the resource.  \\n2. Use:  The process  can operate  on the resource.  \\n3. Release:  The process  releases  the resource.  \\nNecessary  Conditions  for Deadlock  \\n \\nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \\n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \\nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \\ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \\nprocess  must  be delayed  until the resource  has been  released.  \\n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \\nresources.  \\nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \\nadditional  resource  that are currently  being  held by other processes.  \\n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \\nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \\nvoluntarily  by the process holding  it. \\n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \\nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \\u2026, P0} of  \\nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \\nheld by P2, \\u2026, Pn\\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \\nby P0. \\nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \\n\\u201chold -and-wait\\u201d  condition  between  two or more  processes,  so \\u201cone\\u201d  process  cannot  hold a resource,  yet be\\n\\nQuestion: How to prevent Deadlock?\\nHelpful Answer:\"]", "mlflow.spanOutputs": "{\"generations\": [[{\"text\": \" There are four strategies for preventing deadlock: deadlock prevention, deadlock avoidance, deadlock detection and recovery, and the ostrich approach. Deadlock prevention involves negating at least one of the four necessary conditions for deadlock to occur. Deadlock avoidance involves carefully scheduling resources to avoid deadlock. Deadlock detection and recovery involves detecting and recovering from deadlock when it occurs. The ostrich approach involves ignoring the deadlock problem altogether.\", \"generation_info\": {\"finish_reason\": \"stop\", \"logprobs\": null}, \"type\": \"Generation\"}]], \"llm_output\": {\"token_usage\": {\"completion_tokens\": 81, \"total_tokens\": 3120, \"prompt_tokens\": 3039}, \"model_name\": \"gpt-3.5-turbo-instruct\"}, \"run\": null}"}, "events": []}], "request": "{\"query\": \"How to prevent Deadlock?\"}", "response": "{\"result\": \" There are four strategies for preventing deadlock: deadlock prevention, deadlock avoidance, deadlock detection and recovery, and the ostrich approach. Deadlock prevention involves negating at least one of the four necessary conditions for deadlock to occur. Deadlock avoidance involves carefully scheduling resources to avoid deadlock. Deadlock detection and recovery involves detecting and recovering from deadlock when it occurs. The ostrich approach involves ignoring the deadlock problem altogether.\", \"source_documents\": [{\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 45}, \"page_content\": \"Page  47                       \\n \\n \\n \\nResource  Allocation  Graph  with a Cycle  but No Deadlock  \\n \\n \\nMETHODS  OF HANDLING  DEADLOCK  \\n \\nIn general,  there  are four strategies  of dealing  with deadlock problem:  \\n1. Deadlock Prevention : Prevent  deadlock  by resource  scheduling  so as to negate  at least one  of the four \\nconditions.  \\n2. Deadlock  Avoidance : Avoid  deadlock  by careful  resource  scheduling.  \\n3. Deadlock  Detection  and Recovery : Detect  deadlock  and when  it occurs,  take steps  to recover.  \\n4. The Ostrich  Approach:  Just ignore  the deadlock  problem altogether.  \\n \\nDEADLOCK  PREVENTION  \\n \\nA deadlock may  be prevented  by denying  any one of the conditions.  \\n\\uf0b7 Elimination of \\u201cMutual Exclusion\\u201d Condition:  The mutual exclusion condition must hold for non - \\nsharable resources. That is, several processes cannot simultaneously share a single resource. This  \\ncondition is difficult to eliminate because some resources, such as the Hard disc drive and printer, are  \\ninherently non -shareable.  Note  that shareable  resources  like read-only-file do not requir e mutually  \\nexclusive  access and thus  cannot  be involved  in deadlock. \\uf020\\n\\uf0b7 Elimination of \\u201cHold and Wait\\u201d Condition:  There are two possibilities for elimination of the second  \\ncondition. The first alternative is that a process request be granted all of the resour ces it needs at once,  \\nprior to execution. The second alternative is to disallow a process from requesting resources whenever it  \\nhas previously allocated resources. This strategy requires that all of the resources a process will need  \\nmust be requested at once. The system must grant resources on \\u201call or none\\u201d basis. If the complete set  \\nof resources  needed  by a process  is not currently available,  then the  process must wait until the  \\ncomplete set is available. While the process waits, however, it may not hold  any resources. Thus the  \\n\\u201cwait for\\u201d condition is denied and deadlocks cannot occur. This strategy can lead to serious waste of  \\nresources. \\uf020\\n\\uf0b7 Elimination of \\u201cNo -preemption\\u201d Condition:  The non -preemption condition can be alleviated by forcing  \\na process waiting for a resource that cannot immediately be allocated to relinquish all of its currently held  \\nresources, so that other processes may use them to finish. This strategy requires that when a process  \\nthat is holding some resources is denied a request for additio nal resources. The process must release its  \\nheld resources and, if necessary, request them again together with additional resources. Implementation  \\nof this strategy  denies the  \\u201cno-preemptive\\u201d condition  effectively. \\uf020\\n\\uf0b7 Elimination of \\u201cCircular Wait\\u201d Condition:  The last condition, the circular wait, can be denied by  \\nimposing a total ordering on all of the resource types and then forcing, all processes to request the  \\nresources in order (increasing or decreasing). This strategy impose a total ordering of  all resou rces \\ntypes,  and to require  that each  process  requests  resources  in a numerical  order  (increasing  or \\ndecreasing)  of enumeration.  With this rule, the resource  allocation  graph  can never  have  a cycle.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 43}, \"page_content\": \"Page  45                       \\nwaiting  for another resource that it is holding. In addition, deadlock is not possible between two threads in a  \\nprocess, because it is the process that holds resources, not the thread that is, each thread has access to the  \\nresources held  by the process . \\n \\nResource -Allocation  Graph  \\n \\n \\ngraph . Deadlocks  can be described  in terms  of a directed  graph  called  a system  resource -allocation  \\n \\nThis graph  consists  of a set of vertices  V and a set of edges  E. The set of vertices  V is partitioned  into \\ntwo different types of nodes P = {PI, P2, ..., Pn}, the set consisting of all the active processes in the system, and  \\nR = {R1, R2, ..., Rm},  the set consisting  of all  resource  types  in the system.  \\nA directed edge from process Pi to resource type Rj is denoted by Pi \\uf0e0Rj; it signifies that process Pi  \\nrequested an instance of resource type Rj and is currently waiting for that resource. A directed edge Pi \\uf0e0Rj is \\ncalled  a request  edge.  \\nA directed edge from resource type Rj to process Pi is denoted by Rj \\uf0e0Pi; it signifies that an instance of  \\nresource  type Rj has been allocated  to process  Pi. A directed  edge  Rj\\uf0e0Pi is called  an assignment  edge.  \\nPictorially, we represent each process Pi as a circle and each resource type Rj as a square. Since  \\nresource type Rj may have more than one instance, we represent each such instance as a dot within the square.  \\nA request edge points to only the square Rj, wh ereas an assignment edge must designate one of the dots in the  \\nsquare.  \\n \\n \\nThe resource -allocation  graph  shown  below  depicts  the following  situation.  \\nThe sets P, R, and  E: \\nP={P1,P2,P3}  \\nR={R1,R2,R3,R4}  \\nE={P1\\uf0aeR1, P2\\uf0aeR3, R1\\uf0aeP2, R2\\uf0aeP2, R2\\uf0aeP1, R3\\uf0aeP3} \\nResource  instances:  \\n\\uf0b7 One instance  of resource  type R1\\uf020\\n\\uf0b7 Two instances  of resource  type R2\\uf020\\n\\uf0b7 One instance  of resource  type R3\\uf020\\n\\uf0b7 Three  instances  of resource  type R4\\uf020\\nProcess  states:  \\n\\uf0b7 Process  PI is holding  an instance  of resource  type R2, and is waiting  for an instance  of resource  type \\nR1.\\uf020\\n\\uf0b7 Process  P2 is holding  an instance  of R1 and R2, and is waiting  for an instance  of resource  type R3.\\uf020\\n\\uf0b7 Process  P3 is holding  an instance  of R3.\\uf020\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 46}, \"page_content\": \"Page  48                       \\nFor example,  provide  a global  numbering  of all the resources,  as shown  \\n1 \\u2261 Card  reader  \\n2 \\u2261 Printer  \\n3 \\u2261 Optical  driver  \\n4 \\u2261 HDD  \\n5 \\u2261 Card  punch  \\nNow the rule is this: processes can request resources whenever they want to, but all requests must be  \\nmade in numerical order. A process may request first printer and then a HDD(order: 2, 4), but it may not  \\nrequest first a optical driver and then a printer (order: 3, 2). The problem with this strategy is that it may be  \\nimpossible  to find an ordering  that satisfies everyone.  \\n \\nDEADLOCK  AVOIDANCE  \\n \\nThis approach to the deadlock problem anticipates deadlock before it actually occurs. This approach  \\nemploys an algorithm to access the possibility that deadlock could occur and acting accordingly. If  the necessary  \\nconditions for a deadlock are in place, it is still possible to avoid deadlock by being careful when resources are  \\nallocated.  It employs  the most  famous  deadlock  avoidance  algorithm  that is the Banker\\u2019s  algorithm.  \\nA deadlock -avoidance algorithm dynamically examines the resource -allocation state to ensure that a  \\ncircular wait condition can never exist. The resource -allocation state is defined by the number of available and  \\nallocated  resources,  and the maximum  demands of the  processes.  \\n \\nSafe and Unsafe  States  \\n \\nA system is said to be in a Safe State , if there is a safe execution sequence. An execution sequence is  \\nan ordering for process execution such that each process runs until it terminates or blocked and all request for  \\nresources  are immediately  granted  if the resource  is available.  \\nA system is said to be in an Unsafe State , if there is no safe execution sequence. An unsafe state may  \\nnot be deadlocked, but there is at least one sequence of requests from processes that would make the system  \\ndeadlocked.  \\n \\n \\n(Relation  between  Safe,  Unsafe  and Deadlocked  States)  \\n \\n \\nResource -Allocation  Graph  Algorithm  \\n \\nThe deadlock avoidance algorithm uses a variant of the resource -allocation g raph to avoid deadlocked  \\nstate. It introduces a new type of edge, called a claim edge. A claim edge Pi \\uf0e0Rj indicates that process Pi may  \\nrequest resource Rj  at some time in  the future.  This edge resembles  a request edge  in direction,  but is  \\nrepresented by a dashed line. When process Pi requests resource Rj, the claim edge Pi \\uf0e0Rj is converted to a  \\nrequest edge. Similarly, when a resource Rj is released by Pi , the assignment edge Rj \\uf0e0Pi is reconverted to a  \\nclaim  edge  Pi\\uf0e0 Rj.\", \"type\": \"Document\"}, {\"id\": null, \"metadata\": {\"source\": \"operating system.pdf\", \"page\": 42}, \"page_content\": \"Page  44                       \\nLecture  #25 \\n \\nDeadlocks  \\n \\nA set of process is in a deadlock state if each process in the set is waiting for an event that can be  \\ncaused by only another process in the set. In other words, each member of the set of deadlock processes is  \\nwaiting for a resource that can be released only by a deadlock process. None of the processes can run, none of  \\nthem  can release any  resources,  and none  of them  can be awakened.  \\nThe re sources may be either physical or logical. Examples of physical resources are Printers, Hard Disc  \\nDrives,  Memory  Space,  and CPU Cycles.  Examples  of logical  resources  are Files,  Semaphores,  and Monitors.  \\nThe simplest example of deadlock is where process 1 h as been allocated non -shareable resources A  \\n(say a Hard Disc drive) and process 2 has be allocated non -sharable resource B (say a printer). Now, if it turns  \\nout that process 1 needs resource B (printer) to proceed and process 2 needs resource A (Hard Disc drive) to  \\nproceed and these are the only two processes in the system, each is blocked the other and all useful work in the  \\nsystem stops. This situation is termed deadlock. The system is in deadlock state because each process holds a  \\nresource  being  requeste d by the other  process  neither process  is willing  to release the  resource  it holds.  \\n \\nPreemptable  and  Nonpreemptable  Resources  \\nResources  come  in two flavors:  preemptable  and nonpreemptable.  \\n\\uf0dc A preemptable  resource is one that can be taken away from the process with no ill effects. Memory is an  \\nexample  of a preemptable  resource.  \\n\\uf0dc A nonpreemptable  resource  is one that cannot  be taken  away  from process  (without  causing  ill effect).  \\nFor example,  CD resources are not preemptable  at an arbitrary  moment.  \\n\\uf0dc Reallocating  resources  can resolve  deadlocks  that involve  preemptable  resources.  Deadlocks  that \\ninvolve nonpreemptable  resources  are difficult  to deal with. \\nUnder  the normal  mode  of operation,  a process  may utilize  a resource  in only the following  sequence:  \\n1. Request:  If the request  cannot  be granted  immediately,  then the requesting  process  must  wait until it \\ncan acquire  the resource.  \\n2. Use:  The process  can operate  on the resource.  \\n3. Release:  The process  releases  the resource.  \\nNecessary  Conditions  for Deadlock  \\n \\nCoffman  (1971)  identified  four conditions  that must  hold simultaneously  for there  to be a deadlock . \\n1. Mutual  Exclusion  Condition : The resources  involved  are non-shareable.  \\nExplanation: At least one resource must be held in a non -shareable mode, that is, only one process at a  \\ntime claims exclusive control of the resource. If another process requests that resource, the requesting  \\nprocess  must  be delayed  until the resource  has been  released.  \\n2. Hold and Wait Condit ion: Requesting process hold already the resources while waiting for requested  \\nresources.  \\nExplanation: There must exist a process that is holding a resource already allocated to it while waiting for  \\nadditional  resource  that are currently  being  held by other processes.  \\n4. No-Preemptive  Condition:  Resources  already  allocated  to a process cannot be  preempted.  \\nExplanation:  Resources  cannot  be removed  from the processes  are used  to completion  or released  \\nvoluntarily  by the process holding  it. \\n4. Circular  Wait  Condition : The processes in the system form a circular list or chain where each process  \\nin the list is waiting for a resource held by the next process in the list. There exists a set {P0, P1, \\u2026, P0} of  \\nwaiting processes such that P0 is waiting for a resour ce that is held by P1, P1 is waiting for a resource that is  \\nheld by P2, \\u2026, Pn\\u20131 is waiting  for a resource  that is held by Pn, and P0 is waiting  for a resource  that is held \\nby P0. \\nNote: It is not possible to have a deadlock involving only one single process. The deadlock involves a circular  \\n\\u201chold -and-wait\\u201d  condition  between  two or more  processes,  so \\u201cone\\u201d  process  cannot  hold a resource,  yet be\", \"type\": \"Document\"}]}"}